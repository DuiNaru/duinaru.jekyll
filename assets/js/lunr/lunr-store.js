var store = [{
        "title": "개발과 경험이 함께 하는 블로그",
        "excerpt":"평소에 생각하던 이것저것을 적어볼까 하다가 블로그를 만들게 되었습니다.   블로그를 운영한다면 블로그 서비스를 이용하는 편이 간단하고 편할 듯 했지만, github.io 라는 도메인이 눈에 들어오더군요.   그래서 github pages로 만들게 되었습니다.   준비물   github   github pages를 서비스할 repository를 만들었습니다.   jekyll   github pages는 jekyll을 지원합니다.   jekyll로 만든 소스를 repository에 올려 두는 것 만으로도 빌드-배포를 해주죠.   ruby   jekyll로 만들려면 ruby가 필요합니다.   build를 하거나, plugin을 설치해서 기능을 추가해볼 수 있습니다.   만들기   ruby   jekyll의 build와 여러 plugin을 설치하기 위해 설치해주었습니다.   jekyll 공식 홈페이지에 사용 방법이 친절히 적혀있어서 별 어려움이 없었습니다.   다국어 지원   적어도 2개국어로 운영할 생각이니, 다국어 지원을 위해 polyglot plugin을 설치해 주었습니다.   이 플러그인이 github pages에서 공식적으로 지원하는 플러그인이 아니기에, 단순히 repository에 소스를 올려두는 것으로 빌드가 되지 않습니다.   하지만, 다 방법이 있죠.   테마 선택하기   이 과정에서 시간이 상당히 걸렸습니다.   이걸로 해볼까 저걸로 해볼까 하면서 고르다가 시간이 순식간에 지나가네요.   결국에는 Minimal Mistakes로 하기로 했습니다.   하지만, 여기서 문제가 발생하였습니다.      build할 때, 에러가 발생해요.     polyglot plugin이 작동하질 않아요.     문제 해결   windows환경에서 build할 때, 문자 관련 에러 해결   ruby를 windows환경에서 쓰려다 보니 발생하는 에러 였습니다.           vscode에서 cmd로 빌드 하고 있었기에, chcp 65001 을 이용해서 UTF-8로 바꿔서 해결했습니다.   다르게는 jekyll을 에러가 발생하지 않는 버전으로 바꾸는 방법도 있으나, 아래의 문제로 인해 버전을 제한 할 수 밖에 없었습니다.   Minimal Mistakes과 polyglot plugin을 함께 사용하기   웹 페이지가 제대로 만들어 지지 않는 문제가 발생하였습니다.   시행착오 끝에, 다음과 같이 해결이 되었습니다.   jekyll버전   jekyll를 3.8.6으로 사용하니, polyglot plugin과 함께 작동합니다.   polyglot plugin의 _config.xml설정           languages의 언어 설정 순서를 default_lang에서 설정한 언어를 먼저 오게 설정하니 polyglot plugin이 잘 작동합니다.   기능 추가   언어 선택   다국어 지원을 위해 언어를 바꾸는 기능을 추가해 주었습니다.   페이지 하단에 보이는 KO나 JA같은 것이죠.   댓글   Minimal Mistakes에서도 지원하는 disqus를 이용해서 추가했습니다.   후기   만들다 보니 시간이 꽤나 흘렀습니다.   앞으로는 글도 쓰면서, 이것저것 업데이트 해 볼까 합니다.  ","categories": ["programming"],
        "tags": ["jekyll","ruby"],
        
        "url": "https://duinaru.github.io/2019/10/23/blog-with-development-and-experience",
        
        "teaser":null},{
        "title": "GitHub Pages에서 지원하지 않는 플러그인 쓰기",
        "excerpt":"jekyll을 공식적으로 지원하는 GitHub Pages이지만, 모든 jekyll의 플러그인까지 지원하는 것은 아닙니다.   GitHub Pages는  지원하는 플러그인이 제한 되어있습니다.   이 이외의 플러그인은 GitHub Pages에서 jekyll을 build할때, 제한되어 적용되지 않습니다.   그럼, GitHub Pages에서 jekyll로 웹 페이지 서비스를 만들 때는 일부 플러그인만 사용해야 하는 것 일까요?   반은 맞고 반은 틀립니다.   알아보기 전에, 먼저 어떻게 GitHub Pages가  jekyll를 쓰는지 살펴봅시다.   GitHub Pages with jekyll source   GitHub Pages에서 jekyll을 쓰는 간단한 방법입니다.   공식 도움말에서도 설명하는 방법처럼 jekyll 소스를 repository에 올려두고 GitHub Pages가 jekyll을 build를 하는 방법입니다.   GitHub Pages에서 문제 없이 사용가능한 플러그인으로 제한을 하니, plugin의 호환성 같은 문제들에 대해 신경 덜 쓰고 만들 수 있다는 장점이 있습니다.   GitHub Pages without jekyll source   GitHub Pages는 기본적으로 정적 웹 페이지 호스팅 서비스이므로, jekyll소스가 아닌 웹 파일만 있어도 서비스가 가능합니다.   즉, 무엇으로 만들었던, 서비스에 필요한 파일만 있으면 문제 없다는 것입니다.   이러한 파일들은 jekyll로 build를 할 때, 하위 디렉토리인 _site에 생기니, 이 파일을 직접 GitHub Pages의 repository에 올려서 사용해도 문제 없이 서비스 할 수 있습니다.   GitHub Pages에서 지원하지 않는 jekyll의 Plugin으로 만든 파일이라도 말이죠.   GitHub Pages with an unsupported plugin   지원하지 않는 plugin이라도 로컬에서 build를 한 뒤에 웹 파일만 올리면, 서비스가 가능하게 됩니다.   이를 위해서 우선 어떤 branch가 GitHub Pages로 설정 되어 있는지 확인 해 볼 필요가 있습니다.   repository의 settings에서 GitHub Pages라는 항목을 찾아 볼 수 있습니다.           저는 master branch를 사용중이라고 확인 할 수 있었습니다.   그러므로, master branch에 jekyll로 build한 파일들을 올려두면, GitHub Pages를 서비스 할 수 있게 됩니다.   소스랑 파일을 분리해서 관리   master branch에 build된 파일을 올리니, 소스는 분리하고 싶어졌습니다.   그래서 sources라는 branch를 만들고 소스는 해당 branch에만 push를 하고 있습니다.   하지만, build된 파일은 master branch에 push해야 하니, 매번 branch를 변경해서 push를 해야하는 번거로움이 생겼습니다.   이를 모두 수작업으로 하려면 실수도 하기 마련이고, 번거로우니 아래와 같은 PowerShell Script를 만들어서 자동화하였습니다.   PowerShell Script  chcp 65001 $env:JEKYLL_ENV = 'production' rm -r _site/* git clone -b master https://github.com/DuiNaru/duinaru.github.io.git _site bundle exec jekyll build cd _site git add -A git commit -am 'jekyll build' git push   build시 문자 오류를 해결하기 위한 chcp 65001 과 jekyll을 production환경으로 build하기 위한 $env:JEKYLL_ENV = 'production'이 포함되어있습니다.   jekyll을 production환경으로 build를 해서 올리는 이유에 대해서는 다음에 설명하도록 하겠습니다.   이걸로 지원하지 않는 플러그인이라도 GitHub Pages에 서비스 할 수 있게 되었습니다.  ","categories": ["programming"],
        "tags": ["jekyll","ruby"],
        
        "url": "https://duinaru.github.io/2019/10/26/how-to-make-a-github-pages-work-with-an-unsupported-plugin",
        
        "teaser":null},{
        "title": "Blog에 댓글 기능을 추가하였습니다",
        "excerpt":"사용하고 있는 Minimal Mistakes 테마는 여러 댓글 서비스를 사용할 수 있게 설정 할 수 있어서, 사용해보았습니다.   댓글을 사용할 페이지에 comment: true를 추가하고, _config.xml에 사용할 서비스와 정보를 입력하기만 하면 됩니다.   이번에는 disqus라는 댓글 서비스를 사용해 보았습니다.   disqus에 가입한 뒤에 사이트를 생성해주고, ShortName을 알면 됩니다.   shortname은 사이트를 생성할 때, 또는 생성하고 설정 화면에서도 알 수 있습니다.      site생성          site설정       그런다음에, _config.xml 에 설정하면 됩니다.   가입하고 테마에 사용 설정만 하면 되니 간단하네요.   이제 확인 해봅시다.      안 보이네요.     이유를 찾아봅시다.   이상합니다. 아무리 봐도 위의 설정으로 될 것 같은데요.   그래서, Minimal Mistakes 테마에서 disqus와 관련된 comment소스를 찾아 봤습니다.      _includes\\comments.html      disqus를 위해 section을 만들고 있습니다.   그래서 이번엔 해당 html을 include하는 파일을 찾아봤습니다.      _layouts\\single.html      single 레이아웃 페이지의 일부입니다.   무언가의 조건으로 include를 하고 있는게 보입니다.   site.comments.provider 은 _config.xml 에서 설정했고, page.comments 는 true 로 설정해 두었죠.      jekyll.environment == ‘production’ 는 뭐죠?     아, Minimal Mistakes  comment설정 의 Note가 이 내용인듯 하군요!   jekyll을 production환경으로 build하기   jekyll build 옵션에서 Environment를 설정할 수 있습니다.   이 값는 jekyll.environment로 알아낼 수 있으며,  build 설정에 따라 다른 결과물을 출력 할 수 있게 해줍니다.   Minimal Mistakes 는 production으로 build된 경우에만 comment를 사용하도록 하였기 때문에, build시 Environment를 production으로 설정해야합니다.   GitHub Pages에서 build를 하는 경우라면 자동적으로 production으로 설정되어 build가 되나, 필자는 local에서 build를 하고 있기에 따로 설정을 해주었습니다.   linux환경이였다면 Environment페이지 처럼 하면 되지만, windows라면 다릅니다.   cmd인 경우  set JEKYLL_ENV=production   powershell인 경우  $env:JEKYLL_ENV = 'production'   해당 명령어 뒤에 build나 serve를 하면 production으로 만들어집니다.   이로써, Minimal Mistakes 에 댓글 기능을 추가할 수 있었습니다.  ","categories": ["programming"],
        "tags": ["jekyll","ruby"],
        
        "url": "https://duinaru.github.io/2019/11/03/experience-using-comments-with-minimal-mistakes",
        
        "teaser":null},{
        "title": "ruby on rails를 ec2에 구축해보았습니다",
        "excerpt":"ruby를 알게 되었으니 ruby를 이용한 웹 사이트 한번 만들어보고싶어서  ruby on rails로 개발을 시작하였습니다.   개발을 하면서 동시에 ruby on rails를 익히려는 목적이므로 기본적인 환경 구축부터 시작하였습니다.   EC2 생성   AMI   편하게 ubuntu(Ubuntu Server 18.04 LTS (HVM), SSD Volume Type)를 선택하였습니다.   나머지 설정은 free-tier 가능한 설정으로 생성했습니다.   Security groups   SSH 접속 가능하게 22포트는 열어두고, 나머지는 나중에 설정하면서 열어주었습니다.   클릭 몇 번에 생성이 끝났습니다. 고마워요. AWS   설치   SSH로 접속해서, 차근차근 설치를 진행합니다.   Ruby on Rails 의 Getting Started with Rails 를 바탕으로 진행하였습니다.   패키지 업데이트   sudo apt-get update   Ruby 설치   sudo apt-get install ruby-full   Ruby 버전 확인  ruby -v  rails에서 요구하는 ruby 2.5.0이후 버전인지 확인합니다.          2.5.대 버전이군요.   sqlite3 설치  sudo apt-get install sqlite3   sqlite3 버전 확인  sqlite3 --version   rails 설치  드디어 rails를 설치할 차례입니다.  sudo gem install rails   설치 에러       Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers.    설치 중간에 에러가 나왔습니다. Nokogiri 에서 일부 라이브러리가 없어서 생기는 에러 같군요.   Nokogiri 홈페이지에서 해결법을 찾아봅시다.   install-with-system-libraries처럼 설치하니 되는 군요.  sudo apt-get install pkg-config  rails 설치를 계속 합니다.   rails 버전 확인  rails --version          드디어 설치 완료했습니다. 중간에 에러 나서 당황했네요.   다음엔, Creating the Blog Application으로 메인 화면까지 띄우도록 해보겠습니다.  ","categories": ["programming"],
        "tags": ["ruby","rails","aws","ec2"],
        
        "url": "https://duinaru.github.io/2019/11/14/set-up-ruby-on-rails-ec2",
        
        "teaser":null},{
        "title": "Rails 화면 띄우기 및 Cloud9 사용",
        "excerpt":"샘플 화면 하나를 띄우고, 본격적인 개발에 앞서 IDE를 사용하기로 하였습니다.   blog 생성   blog라는 이름의 rails 어플을 생성하였습니다.  rails new blog  해당 명령어로 미리 설정되어 있는 blog 어플리케이션을 가져와서 다운로드한다네요.   에러 발생   설치는 되었는데, 중간에 에러가 나왔네요. 역시 한번에 되는건 없나봅니다.   Gem::Ext::BuildError: ERROR: Failed to build gem native extension. current directory: /tmp/bundler20191116-12860-iie6sqlite3-1.4.1/gems/sqlite3-1.4.1/ext/sqlite3 /usr/bin/ruby2.5 -r ./siteconf20191116-12860-3nvvhf.rb extconf.rb checking for sqlite3.h... no sqlite3.h is missing. Try 'brew install sqlite3', 'yum install sqlite-devel' or 'apt-get install libsqlite3-dev' and check your shared library search path (the location where your sqlite3 shared library is located). *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers.  Check the mkmf.log file for more details.  You may need configuration options.   sqlite3 1.4.1가 제대로 설치되지 않았다고 나옵니다.   gem install sqlite3 -v '1.4.1'을 해보니 마찬가지로 에러가 나와서 다음 명령어로 해결하였습니다.   sudo apt-get install libsqlite3-dev sudo gem update bundle install   잘 설치되었습니다. rails를 한번 실행해봐야 곘네요.   rails server   또, 에러   에러가 나오는 군요.   /var/lib/gems/2.5.0/gems/webpacker-4.2.0/lib/webpacker/configuration.rb:95:in `rescue in load': Webpacker configuration file not found /home/ubuntu/blog/config/webpacker.yml. Please run rails webpacker:install Error: No such file or directory @ rb_sysopen - /home/ubuntu/blog/config/webpacker.yml (RuntimeError)   webpacker을 설치해달라는 군요.   우선, node.js를 설치해줍니다. 이후 yarn을 설치하고, webpacker를 설치했습니다.   curl -sL https://deb.nodesource.com/setup_13.x | sudo -E bash - sudo apt-get install -y nodejs curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update &amp;&amp; sudo apt-get install yarn rails webpacker:install   설치가 되었습니다. rails 서버도 기동하는 군요.          접속해보기   로컬 환경이였다면, 127.0.0.1:3000으로 접속이 가능했겠지만, ec2라서 살짝 설정을 바꿔주었습니다.   포트를 80 을 접속 가능하도록 Security Group 설정 변경   EC2의 Security Group의 Inbound에 80포트를 설정해주었습니다.   0.0.0.0:80 으로 서버 기동   rails server -b 0.0.0.0 -p 80   접속   EC2의 공인 ip로 접속해보았습니다.      서버 실행 중      메인 화면     드디어 메인 화면이 나왔습니다. 이제부터는 본격적인 개발이 될 듯 하네요.   Cloud9 설정   그 전에, IDE를 설정했습니다.   SSH 접속으로 설정하면 어떤 IDE도 사용할 수 있으나, AWS에 만들어 봤으니, IDE도 AWS를 사용해보았습니다.   Cloud9은 EC2로 처음부터 바로 환경 구축을 할 수도 있지만, 이번에는 미리 만든 EC2가 있으니 만들어 둔 EC2를 사용하였습니다.   Creating an SSH Environment   앞으로 계속 같은 ip 접속하기 위해 elastic ip을 할당하고, 위의 도움말에서 ~/.ssh/authorized_keys를 만드는 과정을 했습니다.   이후, AWS Cloud9 Installer가 실행되어서 이것저것 설치되었습니다.          설치가 끝난 다음, 하단의 bash에 rails server -b 0.0.0.0 -p 80으로 서버를 실행하고 접속 할 수 있었습니다.   이제 본격적으로 개발을 할 수 있겠네요.  ","categories": ["programming"],
        "tags": ["ruby","rails","aws","cloud9"],
        
        "url": "https://duinaru.github.io/2019/11/16/develop-using-cloud9",
        
        "teaser":null},{
        "title": "SSM와 CloudWatch로 로그인할 때, EC2가 자동 시작되게 하기",
        "excerpt":"Cloud9를 수동으로 만든 EC2로 사용하다보니, 자동으로 만들 때 사용할 수 있는 EC2의 자동 시작-종료 기능을 사용할 수 없어서, 만들어 보기로 했습니다.   다만, Cloud9이 시작할 때 EC2를 시작 시킬 수 없어서 Console에 Sign in 할 때, 시작 되도록 만들었습니다.   AWS System Manager   EC2를 실행시키기 위해 SSM을 사용할 생각입니다.   그러기 위해서는 SSM가 EC2를 관리 할 수 있도록 설정을 해야 합니다.   IAM의 Role 생성 : AmazonSSMManagedInstanceCore   EC2를 SSM에서 사용하기 위해서 IAM role을 설정해야 합니다.   AmazonSSMManagedInstanceCore의 policy를 선택해서 하나 만들어 줍니다.          해당 IAM을 자동 시작시키려는 EC2에 붙여 주면 됩니다.   Attaching an IAM Role to an Instance   위의 링크처럼 붙여주면 됩니다.   IAM의 Role 생성 : AmazonSSMAutomationRole   이번에는 SSM을 실행 할 때 필요한 IAM role을 만들어야 합니다.   AmazonSSMAutomationRole의 policy를 선택해서 만들어 주면 됩니다.          다음은 로그인 이벤트가 발생하면 SSM으로 EC2가 시작되도록 설정합니다.   CloudTrail 설정   로그인 이벤트를 이용하기 위해서는 CloudTrail를 설정할 필요가 있습니다.   CloudTrail의 왼쪽 메뉴에서 Trails - Create Trail 를 순서대로 눌러줍시다.          만들고 설정을 보면 Logging 이 ON 이 되어 있는 것을 확인 할 수 있습니다.          설정이 끝났습니다.   CloudWatch의 Rules설정   로그인 이벤트를 CloudWatch 에서 감지해서 처리하도록 해봅시다.   CloudWatch의 왼쪽 메뉴에서 Rules - Creates rule 를 순서대로 눌러줍시다.   Event Source          Service Name 은 AWS Console Sign-in 을 선택합니다.   어떤 유저라도 로그인 할 때 처리할 생각이면, Any user을 선택하고,   특정 유저만 로그인 할 때 처리할 생각이면, Specific users(s) by ARN 을 선택해서 해당 유저의 arn 을 넣어줍시다.   Targets      로그인 이벤트의 기록과 EC2가 시작되도록 설정합시다.   CloudWatch log Group에는 Log Group를 적당히 입력하고,   SSM Automation은 Document를 AWS-StartEC2Instance를 선택, InstanceId에 시작시키고 싶은 인스턴스의 ID를 넣어줍니다.   그 아래는 Use existing role 을 선택하고 IAM의 Role 생성 : AmazonSSMAutomationRole에서 만든 Role를 지정해줍시다.          name을 지정하고 Enabled가 체크된 상태에서 만들면 됩니다.   확인해보기   제대로 EC2가 실행되는지 확인해 봅시다.   그러려면 다시 로그인을 해야 겠네요.   1~2분정도의 시간이 지나니, Targets에서 만든 CloudWatch의 Log Group에 로그인 이벤트가 기록되고, EC2가 기동하고 있었습니다.   후기   CloudTrail를 설정하지 않아, 로그인 이벤트가 연결 안 된다거나   SSM Automation의 role를 제대로 설정하지 않아 rule이 실행 되지 않다거나 등등   이것저것 시행착오를 겪어서 성공하게 되었네요.   Cloud9에서 만들 때 사용가능한 EC2의 자동 시작과 비슷하게 쓸 수 있겠네요.   다음엔 일정 시간 동안 접속이 없으면 종료되도록 해 볼 생각입니다.  ","categories": ["aws"],
        "tags": ["aws","ec2","ssm","cloudtrail","cloudwatch","cloud9"],
        
        "url": "https://duinaru.github.io/2019/11/18/auto-start-ec2-on-sign-in",
        
        "teaser":null},{
        "title": "CloudWatch를 이용하여 일정 시간 동안 SSH 연결이 없을 때, EC2 자동 종료 시키기",
        "excerpt":"주로 Cloud9로 사용하는 EC2가 SSH 연결이 없을 때는 사용할 일이 없어서, 일정 시간 대기 한 뒤에 자동 종료가 되도록 만들어 보았습니다.   EC2에서 실행되는 스크립트 만으로도 가능할 듯 하지만, AWS에서 SSH의 연결 수도 모니터링할 수 있게 하도록 CloudWatch를 이용하였습니다.   IAM User 작성   CloudWatch로 SSH의 연결 수를 보내는 역할을 하는 User가 필요합니다.   aws cli에서 접속이 가능하고 권한은 CloudWatchAgentServerPolicy을 가진 User를 생성하였습니다.          EC2에 aws cli 설정   CloudWatch로 SSH의 연결 수를 보내기 위해서 EC2에 aws cli를 설치하고, 위에서 만든 User를 설정해줍니다.   설치   aws cli를 설치해줍니다.   Install the AWS CLI version 1 on Linux   User 설정   방금 만든 User로 설정해줍니다.   Configuring the AWS CLI   SSH 연결 수 알아내기   현재 연결된 SSH의 수를 알아낼 수 있어야 CloudWatch로 보낼 수 있을 것입니다.   연결 되어 있는 사용자를 알아내는 방법   who   해당 명령어로 현재 접속되어 있는 사용자를 알아 낼 수 있습니다.   SSH로 접속했을 경우, 아래와 같이 확인할 수 있습니다.          다만, Cloud9로 접속했을 경우에는 아무것도 나오지 않는 것을 확인 할 수 있습니다.          Cloud9의 연결은 확인 되지 않음   왜 일까요?   Cloud9의 SSH Host Requirements을 보면 SSH 접속 가능이 요구되어 있어서 SSH를 이용하는 것은 알 수가 있습니다.   현재 실행 중인 SSHD의 갯수로 알아내기   SSH로 연결은 하는 것 같으니까, 실행 중인 SSHD를 알아봅시다.   ps -A x | grep \"sshd\"          sshd: ubuntu [priv]과 sshd: ubuntu@notty이 각각 2개씩, 총 4개가 보이네요.   SSH로 접속할 때 보안 강화의 방법으로 priv 로 프로세스를 만든다음, 자식 프로세스를 만들어서 처리시킨다고 하네요.      UsePrivilegeSeparation    그래서 한 개의 SSH 접속에 2개의 프로세스가 만들어 지나 봅니다.   그럼 현재 2개의 SSH 연결이 있다는 것을 알 수 있네요.   다음 명령으로 SSH 연결 수를 알아냅니다.   ps -A x | grep \"sshd\" | grep \"\\\\[priv\\\\]\" | wc -l          SSH 연결 수 전송   알아낸 SSH 연결 수를 CloudWatch에 전송하도록 합니다.   put-metric-data --namespace &lt;value&gt; --dimensions &lt;value&gt; --metric-name &lt;value&gt; --value &lt;value&gt; --timestamp &lt;value&gt; ...and more options   put-metric-data   aws cli를 이용하여 CloudWatch에 Metric을 보내는 명령입니다.   보낸 데이터를 시간 단위로 기록하게 되고, 시간의 경과에 따른 변화를 살펴 볼 수 있게 됩니다.   해당 명령어로 위에서 알아낸 SSH의 연결 수를 CloudWatch로 보낼 수 있게 됩니다.   demension   보내는 데이터의 상세 정보와 같은 느낌으로 설정할 수 있습니다.   InstanceId=인스턴스ID로 인스턴스 ID를 설정하였는데, 이는 CloudWatch Alarm에서 인스턴스 종료 명령은 InstanceId가 설정되어 있는 Metric만 가능하였기 때문입니다.   그렇기 때문에, 자동 종료를 위해서는 InstanceId로 설정해주어야 합니다.   value   보내는 Metric의 값 입니다.   현재 실행 중인 SSHD의 갯수로 알아내기에서 알아낸 연결 수를 넣어주었습니다.   timestamp   Metric의 시간을 지정해 줄 수 있습니다.   보낼 때의 시간을 구해서 UTC 의 형태로 넣어주었습니다.   crontab   전송을 일정 주기로 반복 시키기 위해서 사용하였습니다.   자세한 설명은 이곳을 보면 되고, 아래와 같이 설정합니다.   반복 수행할 스크립트 작성   /home/ubuntu/ssh-count.sh 으로 다음과 같은 스크립트를 만들었습니다.   #!/bin/bash  SSH_CONNECTIONS=$(ps -A x | grep sshd | grep \\\\[priv\\\\] | wc -l)  TIMESTAMP=$(date --utc +%FT%T.%3NZ)  /home/ubuntu/.local/bin/aws cloudwatch put-metric-data --metric-name \"SSH Connections\" --dimensions InstanceId=\"인스턴스ID\" --namespace \"EC2\" --value $SSH_CONNECTIONS --timestamp $TIMESTAMP   metric-name는 지정 하고 싶은 이름으로, InstanceId는 종료 시키고 싶은 인스턴스의 ID를 넣어줍니다.   crontab에 스크립트 등록   crontab -e에 1분 마다 스크립트를 수행하도록 설정하였습니다.   가장 마지막에 아래 명령을 추가하면 됩니다.   */1 * * * * /home/ubuntu/ssh-count.sh   확인   CloudWatch - Metrics 에서 Custom Namespaces 항목의 EC2 - InstanceId 에서 확인 할 수 있습니다.   EC2 자동 종료   이제 일정 시간 내에 SSH 연결 수가 0이면, EC2를 자동으로 종료되도록 만들어 볼 것입니다.   CloudWatch Alarm 설정   CloudWatch - Alarms 에서 Create alarm 을 눌러서 Alarm을 만듭니다.   Specify metric and conditions   이 화면에서는 사용할 Metric의 선택과 설정을 할 수 있습니다.   Metric   Select Metric 을 눌러서 방금 만든 Metric을 선택하고, Statistic와 Period를 확인합니다.   Period의 기간내의 수집된 Metric을 Statistic에서 설정한 방법대로 통계내서 확인하게 되므로, 1분 간격의 데이터를 전부 보기 위해 Period를 1분으로 설정하였습니다.   Conditions   Threshold type는 Static, Whenever는 Lower/Equal, than은 0로 설정해서 값이 0이하이면 Alarm이 되도록 하였습니다.          Additional configuration   0이하로 되자마자 Alarm이 되지 않도록 Datapoints to alarm을 설정하였습니다.          최근 15갯수내에서 0이하가 15개 이면 Alarm이 되도록 하였습니다. Period를 1분으로 설정했으니, 15분 동안 계속 0이하이면 Alarm이 되는 셈이죠.   Configure actions   이 화면에서는 상태에 따라 취할 Action을 설정합니다.   Notification   AWS SNS로 알림을 보낼 생각이 있으면, 설정합니다.   하지 않을 생각이면, Remove를 눌러주세요.   EC2 action   EC2에 종료 명령을 내릴 수 있게 할 수 있습니다.   아래처럼 Alarm의 경우에 Stop this instance 을 하도록 설정해 주었습니다.          그리고, 나머지는 적당히 입력해서 완성했습니다.   확인   CloudWatch - Alarms 에서 확인이 가능합니다.   종료 할 때에는 ALARM, 종료 후 시간이 지나면 INSUFFICIENT, 실행 중일 때에는 OK 로 변하는 것을 볼 수 있을 것입니다.   한계      매우 짧은 연결   1분 마다 현재 실행중인 SSHD를 세어서 보내기 때문어, 샘플링 주기의 사이에 실행되고 종료되는 SSHD가 있다면, 기록 되지 않을 것입니다.   이러한 연결이 의미가 있는 연결일 것이라고 생각 되지 않기에, 별 문제는 없어보입니다.   연결이 될 때 put-metric-data를 실행하도록 하면 해결이 되기도 하죠.      연결이 없어도 기다리는 SSHD   사용하지 않고 있더라도 SSHD가 바로 종료되는 것은 아니기에, 정확한 연결 수를 얻어내려면 추가적인 설정이 필요로 할 듯 합니다. ClientAliveInterval이랑 ClientAliveCountMax와 같은 설정으로 말이죠.      종료 직전에 SSH 연결   SSH 연결 수를 전송하고 Alarm에서 감지하여 종료되기 사이에 새로운 접속이 있을 경우를 생각해 볼 수 있는데, 접속하자마자 종료가 될 듯하므로, 문제는 없을 듯 합니다.   소감   Cloud9으로만 사용할 생각이면, Cloud9에서 EC2를 만드는 것이 Cloud9에 맞춰서 자동 종료가 되기에 좋습니다.   다만, 자동 종료 기능은 Cloud9을 종료하고 일정 시간 뒤에 EC2가 종료 되기 때문에, Cloud9을 종료후에도 사용할 경우가 있다면 자동 종료 기능을 꺼야 하므로 직접 구축한 EC2와 큰 차이가 없게 됩니다.   또는, EC2를 수동으로 구축한 경우도 생각해볼 수 있습니다.   이런 경우에도 자동으로 종료 시키는 것은 가능하다는 것을 알았습니다.   이 글의 방법에서 SSH의 연결 수를 알아내어 전송하는 부분을 변경하면 다른 상황에서도 사용 할 수 있을듯 합니다.  ","categories": ["aws"],
        "tags": ["aws","ec2","cloudwatch","alarm","ssh","crontab"],
        
        "url": "https://duinaru.github.io/2019/12/01/stop-ec2-when-no-ssh-connection-for-a-while",
        
        "teaser":null}]
